TH√äM CH·ª®C NƒÇNG T·ª∞ H·ªåC CHO ESP32-S3 UV PREDICTION
================================================================

1. M√î T·∫¢ T·ªîNG QUAN
------------------
- ESP32-S3 t·ª± ƒëi·ªÅu ch·ªânh model d·ª± ƒëo√°n UV d·ª±a tr√™n d·ªØ li·ªáu th·ª±c t·∫ø
- Model base: TinyML neural network v·ªõi input [UV_t-3, UV_t-2, UV_t-1, HR] 
- So s√°nh prediction vs actual UV, c·∫≠p nh·∫≠t bias correction
- L∆∞u learning state v√†o EEPROM, sync cloud Firebase (t∆∞∆°ng th√≠ch SmartUV system)
- Ti·∫øt ki·ªám t√†i nguy√™n ƒë·ªÉ ESP32-S3 c√≤n l√†m vi·ªác kh√°c

2. MODEL ARCHITECTURE T∆Ø∆†NG TH√çCH
---------------------------------
```cpp
// Model input format (ph√π h·ª£p v·ªõi notebook training)
struct ModelInput {
    float uv_history[3];    // UV_t-3, UV_t-2, UV_t-1 (normalized 0-1)
    float hour;             // Hour of day (normalized 0-1)
};

// Model output
struct ModelOutput {
    float predicted_uv;     // UV prediction (denormalized)
};

// Scaling parameters (t·ª´ notebook training)
const float input_min[4] = {0.0f, 0.0f, 0.0f, 0.0f};      // UV min = 0, HR min = 0
const float input_max[4] = {15.0f, 15.0f, 15.0f, 23.0f};  // UV max = 15, HR max = 23
const float output_min = 0.0f;                              // UV output min
const float output_max = 15.0f;                             // UV output max
```

3. CODE IMPLEMENTATION CHI TI·∫æT
-------------------------------

A. STRUCT L∆ØU LEARNING STATE (T∆Ø∆†NG TH√çCH NOTEBOOK):
```cpp
#include <EEPROM.h>
#include <WiFi.h>
#include <FirebaseESP32.h>  // Firebase cho SmartUV system

struct LearningState {
    float bias_adjustment = 0.0;      // Bias t·ªïng qu√°t
    float hourly_bias[24] = {0};      // Bias ri√™ng cho t·ª´ng gi·ªù (0-23h)
    float learning_rate = 0.01;       // T·ªëc ƒë·ªô h·ªçc adaptive
    int sample_count = 0;             // S·ªë m·∫´u ƒë√£ h·ªçc
    float avg_error = 0.0;            // L·ªói trung b√¨nh exponential moving average
    float confidence_score = 1.0;     // ƒê·ªô tin c·∫≠y model (0-1)
    unsigned long last_update = 0;    // Timestamp c·∫≠p nh·∫≠t cu·ªëi
    float seasonal_factor = 1.0;      // Y·∫øu t·ªë theo m√πa
    uint32_t crc_checksum = 0;        // Checksum ƒë·ªÉ validate data integrity
};

LearningState learning;

// Firebase config cho SmartUV system integration
#define FIREBASE_HOST "smartuv-project-default-rtdb.asia-southeast1.firebasedatabase.app"
#define FIREBASE_AUTH "your-firebase-secret-key"  // Thay b·∫±ng key th·∫≠t
FirebaseData firebaseData;
FirebaseConfig firebaseConfig;
FirebaseAuth firebaseAuth;

B. H√ÄM KH·ªûI T·∫†O V√Ä L∆ØU TR·ªÆ:
```cpp
void initLearning() {
    EEPROM.begin(512);
    loadLearningState();
    Serial.println("Learning system initialized");
    printLearningStats();
}

void loadLearningState() {
    EEPROM.get(0, learning);
    
    // Validation v√† reset n·∫øu data corrupted
    if (isnan(learning.bias_adjustment) || 
        abs(learning.bias_adjustment) > 5.0 ||
        learning.sample_count < 0) {
        Serial.println("Corrupted learning state, resetting...");
        resetLearningState();
    }
}

void saveLearningState() {
    EEPROM.put(0, learning);
    EEPROM.commit();
    learning.last_update = millis();
}

void resetLearningState() {
    learning = LearningState(); // Reset to default values
    for (int i = 0; i < 24; i++) {
        learning.hourly_bias[i] = 0.0;
    }
    saveLearningState();
    Serial.println("Learning state reset to defaults");
}
```

C. H√ÄM C·∫¨P NH·∫¨T MODEL (CORE LEARNING):
```cpp
void updateModel(float predicted_uv, float actual_uv, int hour) {
    float error = actual_uv - predicted_uv;
    float abs_error = abs(error);
    
    // Ch·ªâ h·ªçc t·ª´ data ƒë√°ng tin c·∫≠y (tr√°nh outliers)
    if (abs_error < 3.0 && isValidUVReading(actual_uv, hour)) {
        
        // C·∫≠p nh·∫≠t bias t·ªïng qu√°t
        learning.avg_error = 0.9 * learning.avg_error + 0.1 * error;
        learning.bias_adjustment += learning.learning_rate * error;
        
        // C·∫≠p nh·∫≠t bias ri√™ng theo gi·ªù
        learning.hourly_bias[hour] += learning.learning_rate * error * 0.5;
        
        // C·∫≠p nh·∫≠t confidence score
        learning.confidence_score = 0.95 * learning.confidence_score + 
                                   0.05 * (1.0 / (1.0 + abs_error));
        
        // Increment sample count
        learning.sample_count++;
        
        // Adaptive learning rate (gi·∫£m d·∫ßn theo th·ªùi gian)
        if (learning.sample_count % 100 == 0) {
            learning.learning_rate *= 0.99;
            learning.learning_rate = max(0.001, learning.learning_rate);
        }
        
        // Gi·ªõi h·∫°n bias ƒë·ªÉ tr√°nh drift qu√° xa model g·ªëc
        learning.bias_adjustment = constrain(learning.bias_adjustment, -2.0, 2.0);
        for (int i = 0; i < 24; i++) {
            learning.hourly_bias[i] = constrain(learning.hourly_bias[i], -1.5, 1.5);
        }
        
        // L∆∞u state m·ªói 10 updates ho·∫∑c error l·ªõn
        if (learning.sample_count % 10 == 0 || abs_error > 1.0) {
            saveLearningState();
        }
        
        Serial.printf("Learning update: Error=%.2f, Bias=%.3f, Confidence=%.3f\n", 
                     error, learning.bias_adjustment, learning.confidence_score);
    }
}

bool isValidUVReading(float uv, int hour) {
    // Validation logic d·ª±a tr√™n th·ªùi gian v√† gi√° tr·ªã h·ª£p l√Ω
    if (hour >= 18 || hour <= 6) {
        return uv >= 0 && uv <= 1.0; // Ban ƒë√™m UV r·∫•t th·∫•p
    } else if (hour >= 10 && hour <= 14) {
        return uv >= 0 && uv <= 15.0; // Tr∆∞a UV cao nh·∫•t
    } else {
        return uv >= 0 && uv <= 8.0; // S√°ng/chi·ªÅu UV trung b√¨nh
    }
}
```

D. H√ÄM D·ª∞ ƒêO√ÅN V·ªöI ADAPTIVE CORRECTION (T∆Ø∆†NG TH√çCH MODEL):
```cpp
float predictUV(float uv_t3, float uv_t2, float uv_t1, int hour) {
    // Chu·∫©n h√≥a input theo format notebook training
    float normalized_inputs[4];
    normalized_inputs[0] = (uv_t3 - input_min[0]) / (input_max[0] - input_min[0]);  // UV_t-3
    normalized_inputs[1] = (uv_t2 - input_min[1]) / (input_max[1] - input_min[1]);  // UV_t-2  
    normalized_inputs[2] = (uv_t1 - input_min[2]) / (input_max[2] - input_min[2]);  // UV_t-1
    normalized_inputs[3] = (float(hour) - input_min[3]) / (input_max[3] - input_min[3]); // Hour
    
    // G·ªçi TinyML model (t·ª´ notebook)
    float base_prediction = runTinyMLModel(normalized_inputs);
    
    // Denormalize output
    base_prediction = base_prediction * (output_max - output_min) + output_min;
    
    // √Åp d·ª•ng adaptive correction layers
    float corrected_prediction = applyCorrection(base_prediction, hour);
    
    return max(0.0f, min(15.0f, corrected_prediction)); // Gi·ªõi h·∫°n UV 0-15
}

float applyCorrection(float base_prediction, int hour) {
    // √Åp d·ª•ng bias t·ªïng qu√°t (weighted by confidence)
    float corrected = base_prediction + 
                     (learning.bias_adjustment * learning.confidence_score);
    
    // √Åp d·ª•ng bias ri√™ng theo gi·ªù
    corrected += learning.hourly_bias[hour] * learning.confidence_score;
    
    // √Åp d·ª•ng seasonal factor
    corrected *= learning.seasonal_factor;
    
    return corrected;
}

// TinyML model wrapper (t∆∞∆°ng th√≠ch v·ªõi code t·ª´ notebook)
float runTinyMLModel(float* normalized_inputs) {
    // Set input tensor (4 inputs: UV_t-3, UV_t-2, UV_t-1, HR)
    TfLiteTensor* input = interpreter->input(0);
    for (int i = 0; i < 4; i++) {
        input->data.f[i] = normalized_inputs[i];
    }
    
    // Run inference
    TfLiteStatus invoke_status = interpreter->Invoke();
    if (invoke_status != kTfLiteOk) {
        Serial.println("‚ùå TinyML inference failed!");
        return -1.0f;
    }
    
    // Get output (normalized)
    TfLiteTensor* output = interpreter->output(0);
    return output->data.f[0];
}
```

E. FIREBASE CLOUD SYNC (SMARTUV SYSTEM INTEGRATION):
```cpp
void setupFirebase() {
    // Firebase configuration cho SmartUV project
    firebaseConfig.host = FIREBASE_HOST;
    firebaseConfig.signer.tokens.legacy_token = FIREBASE_AUTH;
    
    Firebase.begin(&firebaseConfig, &firebaseAuth);
    Firebase.reconnectWiFi(true);
    
    Serial.println("üî• Firebase initialized for SmartUV system");
}

void syncToFirebase() {
    if (WiFi.status() == WL_CONNECTED && 
        learning.sample_count > 0 && 
        learning.sample_count % 50 == 0) {
        
        String deviceId = getESP32DeviceID();
        String basePath = "/devices/" + deviceId + "/learning/";
        
        // Upload learning state t∆∞∆°ng th√≠ch SmartUV schema
        Firebase.setFloat(firebaseData, basePath + "bias_adjustment", learning.bias_adjustment);
        Firebase.setFloat(firebaseData, basePath + "confidence_score", learning.confidence_score);
        Firebase.setInt(firebaseData, basePath + "sample_count", learning.sample_count);
        Firebase.setFloat(firebaseData, basePath + "avg_error", learning.avg_error);
        Firebase.setFloat(firebaseData, basePath + "seasonal_factor", learning.seasonal_factor);
        Firebase.setString(firebaseData, basePath + "last_update", String(millis()));
        
        // Upload hourly bias array
        for (int i = 0; i < 24; i++) {
            Firebase.setFloat(firebaseData, basePath + "hourly_bias/" + String(i), 
                            learning.hourly_bias[i]);
        }
        
        // Upload device metadata
        Firebase.setString(firebaseData, basePath + "device_type", "ESP32-S3");
        Firebase.setString(firebaseData, basePath + "model_version", "TinyML-v1.0");
        Firebase.setString(firebaseData, basePath + "location", "YOUR_LOCATION");
        
        Serial.println("üî• Learning state synced to SmartUV Firebase");
        
        // Download global learning parameters
        downloadGlobalLearning();
    }
}

void downloadGlobalLearning() {
    // Download global bias t·ª´ SmartUV system
    if (Firebase.getFloat(firebaseData, "/global_learning/avg_bias")) {
        float global_bias = firebaseData.floatData();
        
        if (!isnan(global_bias) && abs(global_bias) < 2.0) {
            // Blend v·ªõi local learning (conservative approach)
            learning.bias_adjustment = 0.8 * learning.bias_adjustment + 
                                      0.2 * global_bias;
            Serial.printf("üåç Blended with global bias: %.3f\n", global_bias);
        }
    }
    
    // Download seasonal factors t·ª´ cloud
    if (Firebase.getFloat(firebaseData, "/global_learning/seasonal_factor")) {
        float seasonal = firebaseData.floatData();
        if (seasonal > 0.5 && seasonal < 2.0) {
            learning.seasonal_factor = 0.9 * learning.seasonal_factor + 0.1 * seasonal;
        }
    }
}

String getESP32DeviceID() {
    // T·∫°o unique device ID t·ª´ MAC address
    uint64_t chipid = ESP.getEfuseMac();
    return "ESP32_" + String((uint32_t)(chipid >> 32), HEX) + 
           String((uint32_t)chipid, HEX);
}

// Sync v·ªõi SmartUV mobile app data
void syncWithMobileApp() {
    String deviceId = getESP32DeviceID();
    String appDataPath = "/app_data/" + deviceId + "/uv_readings/";
    
    // Download recent UV readings t·ª´ mobile app
    if (Firebase.getFloat(firebaseData, appDataPath + "last_manual_reading")) {
        float manual_uv = firebaseData.floatData();
        
        // S·ª≠ d·ª•ng manual reading ƒë·ªÉ improve learning
        if (manual_uv > 0 && manual_uv < 15) {
            // Add to learning dataset
            Serial.printf("üì± Manual UV reading from app: %.2f\n", manual_uv);
        }
    }
}
```

F. TASK QU·∫¢N L√ù V√Ä MONITORING:
```cpp
TaskHandle_t learningTaskHandle;

void learningTask(void* parameter) {
    TickType_t xLastWakeTime = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(300000); // 5 ph√∫t
    
    while (true) {
        // Ki·ªÉm tra s·ª©c kh·ªèe learning system
        checkLearningHealth();
        
        // Periodic Firebase sync
        if (learning.sample_count % 50 == 0) {
            syncToFirebase();
        }
        
        // Memory management
        manageResources();
        
        // Wait for next cycle
        vTaskDelayUntil(&xLastWakeTime, xFrequency);
    }
}

void checkLearningHealth() {
    // Reset n·∫øu learning drift qu√° xa
    if (abs(learning.avg_error) > 3.0 || 
        learning.confidence_score < 0.2 ||
        abs(learning.bias_adjustment) > 4.0) {
        
        Serial.println("Learning drift detected, performing soft reset...");
        
        // Soft reset: gi·∫£m bias v·ªÅ 50% thay v√¨ reset ho√†n to√†n
        learning.bias_adjustment *= 0.5;
        learning.confidence_score = 0.5;
        for (int i = 0; i < 24; i++) {
            learning.hourly_bias[i] *= 0.5;
        }
        
        saveLearningState();
    }
}

void manageResources() {
    // Ki·ªÉm tra memory usage
    size_t freeHeap = ESP.getFreeHeap();
    if (freeHeap < 10000) { // < 10KB free
        Serial.printf("Low memory warning: %d bytes free\n", freeHeap);
    }
    
    // Cleanup n·∫øu c·∫ßn
    if (learning.sample_count > 10000) {
        // Archive old data v√† reset counters
        archiveLearningData();
    }
}

void archiveLearningData() {
    // L∆∞u learning state v√†o backup file
    // Reset sample_count nh∆∞ng gi·ªØ bias values
    learning.sample_count = 0;
    learning.learning_rate = 0.01; // Reset learning rate
    saveLearningState();
    Serial.println("Learning data archived, counters reset");
}
```

3. T√çCH H·ª¢P V√ÄO MAIN CODE
------------------------

A. TRONG setup():
```cpp
void setup() {
    Serial.begin(115200);
    
    // Initialize learning system
    initLearning();
    
    // Create learning background task
    xTaskCreate(learningTask, "Learning", 4096, NULL, 1, &learningTaskHandle);
    
    // Other initialization...
    setupUVSensor();
    setupWiFi();
    setupFirebase();
}
```

B. TRONG MAIN LOOP (T∆Ø∆†NG TH√çCH MODEL NOTEBOOK):
```cpp
void loop() {
    static float uv_history[3] = {2.0, 3.5, 4.2};  // Initialize v·ªõi gi√° tr·ªã h·ª£p l√Ω
    static unsigned long last_prediction = 0;
    
    // Update m·ªói 5 ph√∫t cho demo, th·ª±c t·∫ø c√≥ th·ªÉ 1 gi·ªù
    if (millis() - last_prediction > 300000) {
        
        // ƒêo UV th·ª±c t·∫ø t·ª´ sensor (ML8511 ho·∫∑c similar)
        float actual_uv = readUVSensor();
        
        // L·∫•y th·ªùi gian hi·ªán t·∫°i
        struct tm timeinfo;
        getLocalTime(&timeinfo);
        int current_hour = timeinfo.tm_hour;
        
        // D·ª± ƒëo√°n UV v·ªõi history hi·ªán t·∫°i
        float predicted_uv = predictUV(uv_history[0], uv_history[1], uv_history[2], current_hour);
        
        // Display k·∫øt qu·∫£ v·ªõi confidence score
        displayUVPrediction(predicted_uv, actual_uv, learning.confidence_score, current_hour);
        
        // Learning update n·∫øu c√≥ actual UV ƒë√°ng tin c·∫≠y
        if (actual_uv >= 0 && isValidUVReading(actual_uv, current_hour)) {
            updateModel(predicted_uv, actual_uv, current_hour);
            
            // Update UV history for next prediction
            uv_history[0] = uv_history[1];  // Shift left
            uv_history[1] = uv_history[2];
            uv_history[2] = actual_uv;      // Add latest reading
        }
        
        // Sync with SmartUV Firebase system
        if (learning.sample_count % 25 == 0) {
            syncToFirebase();
            syncWithMobileApp();
        }
        
        // Other ESP32-S3 tasks
        handleOtherTasks();
        updateDisplay();
        processWebRequests();
        
        last_prediction = millis();
    }
    
    // Keep WiFi alive
    if (WiFi.status() != WL_CONNECTED) {
        reconnectWiFi();
    }
    
    delay(1000);  // Short delay for responsiveness
}

// UV sensor reading function (implement theo hardware)
float readUVSensor() {
    // Cho ML8511 sensor:
    int sensorValue = analogRead(UV_SENSOR_PIN);
    float voltage = sensorValue * (3.3 / 4095.0);  // ESP32 ADC conversion
    
    // ML8511 voltage to UV mapping
    float uv_index = 0.0;
    if (voltage >= 1.0) {
        uv_index = (voltage - 1.0) * (15.0 / 2.0);  // Linear approximation
    }
    
    return constrain(uv_index, 0.0, 15.0);
}
```

C. UTILITY FUNCTIONS (T∆Ø∆†NG TH√çCH SMARTUV SYSTEM):
```cpp
void displayUVPrediction(float predicted, float actual, float confidence, int hour) {
    // Display tr√™n TFT (n·∫øu c√≥)
    Serial.printf("üåû UV Prediction @ %02d:00\n", hour);
    Serial.printf("   Predicted: %.1f (%.0f%% confidence)\n", predicted, confidence * 100);
    Serial.printf("   Actual: %.1f\n", actual);
    Serial.printf("   Error: %.2f\n", abs(predicted - actual));
    
    // Color-coded display
    uint16_t color = TFT_GREEN;
    String category = "LOW";
    
    if (predicted > 8.0) {
        color = TFT_RED;
        category = "HIGH";
    } else if (predicted > 5.0) {
        color = TFT_ORANGE; 
        category = "MODERATE";
    }
    
    // Update display n·∫øu c√≥ TFT
    if (tft.width() > 0) {
        tft.fillRect(0, 60, 240, 40, TFT_BLACK);
        tft.setTextColor(color);
        tft.setTextSize(2);
        tft.drawString("UV: " + String(predicted, 1), 10, 60);
        tft.setTextSize(1);
        tft.drawString(category + " (" + String(confidence*100, 0) + "%)", 10, 85);
    }
    
    // Log to SmartUV system
    logToSmartUVSystem(predicted, actual, confidence, hour);
}

void logToSmartUVSystem(float predicted, float actual, float confidence, int hour) {
    // T·∫°o log entry cho SmartUV analytics
    String deviceId = getESP32DeviceID();
    String logPath = "/logs/" + deviceId + "/" + String(millis());
    
    // Create JSON-like structure
    Firebase.setFloat(firebaseData, logPath + "/predicted_uv", predicted);
    Firebase.setFloat(firebaseData, logPath + "/actual_uv", actual);
    Firebase.setFloat(firebaseData, logPath + "/confidence", confidence);
    Firebase.setInt(firebaseData, logPath + "/hour", hour);
    Firebase.setString(firebaseData, logPath + "/timestamp", String(millis()));
    Firebase.setString(firebaseData, logPath + "/device_type", "ESP32-S3");
}

void printLearningStats() {
    Serial.println("=== SMARTUV LEARNING STATISTICS ===");
    Serial.printf("Device ID: %s\n", getESP32DeviceID().c_str());
    Serial.printf("Bias Adjustment: %.3f\n", learning.bias_adjustment);
    Serial.printf("Average Error: %.3f UV units\n", learning.avg_error);
    Serial.printf("Confidence Score: %.1f%%\n", learning.confidence_score * 100);
    Serial.printf("Sample Count: %d\n", learning.sample_count);
    Serial.printf("Learning Rate: %.4f\n", learning.learning_rate);
    Serial.printf("Seasonal Factor: %.3f\n", learning.seasonal_factor);
    
    Serial.println("Hourly Bias Corrections:");
    for (int i = 0; i < 24; i++) {
        if (abs(learning.hourly_bias[i]) > 0.01) {  // Only show significant bias
            Serial.printf("  %02d:00 -> %+.3f\n", i, learning.hourly_bias[i]);
        }
    }
    Serial.println("===================================");
}

// CRC calculation cho data integrity
uint32_t calculateCRC(LearningState* state) {
    uint32_t crc = 0xFFFFFFFF;
    uint8_t* data = (uint8_t*)state;
    
    for (size_t i = 0; i < sizeof(LearningState) - sizeof(uint32_t); i++) {
        crc ^= data[i];
        for (int j = 0; j < 8; j++) {
            if (crc & 1) {
                crc = (crc >> 1) ^ 0xEDB88320;
            } else {
                crc >>= 1;
            }
        }
    }
    
    return ~crc;
}

// Reconnect WiFi cho stability
void reconnectWiFi() {
    static unsigned long lastReconnect = 0;
    
    if (millis() - lastReconnect > 30000) {  // Try every 30 seconds
        Serial.println("üîÑ Reconnecting WiFi...");
        WiFi.disconnect();
        WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
        lastReconnect = millis();
    }
}

// Integration v·ªõi SmartUV mobile app
void handleSmartUVCommands() {
    // Listen for commands t·ª´ Firebase
    if (Firebase.getString(firebaseData, "/commands/" + getESP32DeviceID() + "/action")) {
        String command = firebaseData.stringData();
        
        if (command == "reset_learning") {
            resetLearningState();
            Serial.println("üì± Learning reset by mobile app");
        } else if (command == "sync_now") {
            syncToFirebase();
            Serial.println("üì± Manual sync triggered by app");
        } else if (command == "print_stats") {
            printLearningStats();
        }
        
        // Clear command after processing
        Firebase.deleteNode(firebaseData, "/commands/" + getESP32DeviceID() + "/action");
    }
}
```

4. RESOURCE MANAGEMENT & OPTIMIZATION (ESP32-S3 SPECIFIC)
--------------------------------------------------------

A. MEMORY FOOTPRINT:
- LearningState struct: ~240 bytes (including CRC)
- Background task stack: 4KB
- TinyML model: ~20-50KB (t·ª´ notebook)
- Firebase buffers: ~2KB
- Total RAM overhead: < 8KB
- EEPROM usage: ~256 bytes
- Flash backup: ~1KB

B. CPU OPTIMIZATION:
- Learning task priority: 1 (lowest)
- TinyML inference: ~10-20ms (t·ª´ notebook benchmark)
- Simple math operations only
- Async Firebase operations
- Efficient validation v·ªõi early exit

C. POWER MANAGEMENT:
```cpp
void enablePowerSaving() {
    // CPU frequency scaling
    setCpuFrequencyMhz(80);  // Reduce t·ª´ 240MHz down to 80MHz khi kh√¥ng c·∫ßn
    
    // WiFi power save
    WiFi.setSleep(true);
    
    // Disable unnecessary peripherals
    btStop();  // Disable Bluetooth
}

void setupWatchdog() {
    esp_task_wdt_add(learningTaskHandle);
    esp_task_wdt_add(NULL);  // Add main task
}
```

D. STORAGE OPTIMIZATION:
```cpp
// Compress learning data tr∆∞·ªõc khi l∆∞u
void saveLearningStateCompressed() {
    // Simple compression: ch·ªâ l∆∞u significant hourly bias
    uint8_t compressed_data[128];
    size_t compressed_size = compressLearningData(compressed_data);
    
    EEPROM.writeBytes(0, compressed_data, compressed_size);
    EEPROM.commit();
}

size_t compressLearningData(uint8_t* output) {
    size_t pos = 0;
    
    // Essential data only
    memcpy(output + pos, &learning.bias_adjustment, sizeof(float)); pos += sizeof(float);
    memcpy(output + pos, &learning.confidence_score, sizeof(float)); pos += sizeof(float);
    memcpy(output + pos, &learning.sample_count, sizeof(int)); pos += sizeof(int);
    
    // Only significant hourly bias (> 0.1)
    uint8_t significant_count = 0;
    for (int i = 0; i < 24; i++) {
        if (abs(learning.hourly_bias[i]) > 0.1) significant_count++;
    }
    
    output[pos++] = significant_count;
    for (int i = 0; i < 24; i++) {
        if (abs(learning.hourly_bias[i]) > 0.1) {
            output[pos++] = i;  // hour
            memcpy(output + pos, &learning.hourly_bias[i], sizeof(float));
            pos += sizeof(float);
        }
    }
    
    return pos;
}
```

5. DEPLOYMENT CHECKLIST (SMARTUV SYSTEM)
----------------------------------------
‚ñ° Setup Firebase project v·ªõi SmartUV schema
‚ñ° Configure ESP32-S3 partition table (adequate EEPROM space)
‚ñ° Test TinyML model loading v√† inference speed
‚ñ° Validate UV sensor calibration (ML8511)
‚ñ° Test WiFi stability v√† reconnection
‚ñ° Implement OTA update capability cho model updates
‚ñ° Field testing v·ªõi actual weather conditions
‚ñ° Integration testing v·ªõi SmartUV mobile app
‚ñ° Power consumption benchmarking
‚ñ° Long-term stability testing (1 week continuous)

6. TROUBLESHOOTING (PRODUCTION ISSUES)
------------------------------------
- **Learning kh√¥ng converge**: Gi·∫£m learning_rate xu·ªëng 0.005
- **Memory leaks**: Implement periodic memory cleanup
- **Firebase connection fails**: Offline queue + retry mechanism
- **TinyML inference slow**: Check tensor arena size, optimize model
- **UV sensor noise**: Th√™m median filter v√† outlier detection
- **EEPROM corruption**: Implement backup state + CRC validation
- **Power consumption high**: Enable deep sleep mode gi·ªØa predictions

7. INTEGRATION V·ªöI SMARTUV ECOSYSTEM
-----------------------------------

A. MOBILE APP COMMUNICATION:
- Real-time UV predictions stream to app
- Learning statistics dashboard
- Manual UV readings from app improve learning
- Remote control commands (reset, sync, calibrate)

B. CLOUD ANALYTICS:
- Aggregate learning data t·ª´ multiple devices
- Global bias correction distribution
- Seasonal trend analysis
- Device performance monitoring

C. FUTURE ENHANCEMENTS:
- Multi-sensor fusion (temperature, humidity correlation)
- Advanced ensemble learning algorithms
- Edge AI model updates via OTA
- Integration v·ªõi weather API for validation
- Solar irradiance correlation analysis

IMPLEMENTATION NOTES (PRODUCTION READY):
--------------------------------------
- Start v·ªõi conservative learning parameters
- Implement comprehensive logging cho debugging
- Use gradual rollout strategy (5% -> 50% -> 100% devices)
- Maintain fallback to original TinyML model
- Document all learning behavior patterns
- Regular backup learning states to cloud storage
- Monitor device fleet performance via dashboard
- Implement A/B testing cho different learning algorithms

SMARTUV SYSTEM COMPATIBILITY:
---------------------------
‚úÖ Firebase Real-time Database integration
‚úÖ Mobile app command interface  
‚úÖ Device fleet management
‚úÖ Centralized logging v√† analytics
‚úÖ OTA update capability
‚úÖ Power-efficient implementation
‚úÖ Scalable to 100+ devices
‚úÖ Production monitoring ready
